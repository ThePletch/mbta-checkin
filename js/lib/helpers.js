// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Number.prototype.leftPad = function(len, padder) {
    var s;
    s = this.toString();
    if (padder == null) {
      padder = '0';
    }
    while (s.length < len) {
      s = padder + s;
    }
    return s;
  };

  this.Helpers = (function() {

    function Helpers() {}

    Helpers.events = {
      _ev: {},
      bind: function(eventName, func) {
        var bindEvent;
        bindEvent = function(name, boundFunc) {
          var self, _base, _ref;
          self = Helpers.events;
          if ((_ref = (_base = self._ev)[name]) == null) {
            _base[name] = [];
          }
          return self._ev[name].push(boundFunc);
        };
        if (eventName.constructor === Array) {
          return eventName.map(function(name) {
            return bindEvent(name, func);
          });
        } else {
          return bindEvent(eventName, func);
        }
      },
      fire: function(eventName, params) {
        var func, self, _i, _len, _ref, _results;
        self = Helpers.events;
        if (self._ev[eventName] == null) {
          return;
        }
        _ref = self._ev[eventName];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          func = _ref[_i];
          _results.push(func(params));
        }
        return _results;
      }
    };

    Helpers.cache = {
      routes: {},
      stops: {},
      vehicles: {}
    };

    Helpers.ensureJsonParsed = function(json) {
      var _ref;
      if ((_ref = typeof json) === String || _ref === 'string') {
        return JSON.parse(json);
      } else {
        return json;
      }
    };

    Helpers.fetchLocalJson = function(url, callback) {
      return $.get(url, function(data) {
        return callback(Helpers.ensureJsonParsed(data));
      });
    };

    Helpers.iconUrls = {
      red: 'img/red_line.png',
      green: 'img/green_line.png',
      blue: 'img/blue_line.png',
      orange: 'img/orange_line.png',
      yellow: 'img/yellow_line.png',
      locationReticle: 'img/selected_blue.png',
      selected: 'img/selected.png',
      selectedError: 'img/selected_error.png',
      selectedSuccess: 'img/selected_success.png',
      statusLoading: 'img/spinner.gif',
      statusSuccess: 'img/success.png',
      statusError: 'img/error.png'
    };

    Helpers.lineColors = {
      red: '#ff0000',
      green: '#00bb00',
      blue: '#0077cc',
      orange: '#ff8800',
      silver: '#777777',
      bus: '#ffd700'
    };

    Helpers.getLineColor = function(lineColor) {
      switch (lineColor) {
        case 'Green-B':
        case 'Green-C':
        case 'Green-D':
        case 'Green-E':
          return Helpers.lineColors.green;
        case 'Orange':
          return Helpers.lineColors.orange;
        case 'Blue':
          return Helpers.lineColors.blue;
        case 'Red':
        case 'Mattapan':
          return Helpers.lineColors.red;
        case '741':
        case '742':
        case '751':
        case '749':
        case '746':
          return Helpers.lineColors.silver;
        default:
          return Helpers.lineColors.bus;
      }
    };

    Helpers.getLineIcon = function(lineColor) {
      switch (lineColor) {
        case 'Green Line':
        case 'Green Line B':
        case 'Green Line C':
        case 'Green Line D':
        case 'Green Line E':
          return Helpers.iconUrls.green;
        case 'Orange Line':
          return Helpers.iconUrls.orange;
        case 'Blue Line':
          return Helpers.iconUrls.blue;
        case 'Red Line':
        case 'Mattapan Trolley':
          return Helpers.iconUrls.red;
        case 'Location':
          return Helpers.iconUrls.locationReticle;
        default:
          return Helpers.iconUrls.yellow;
      }
    };

    Helpers.getLiveIcon = function(train) {
      return {
        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
        fillColor: train.line.color,
        fillOpacity: 1,
        rotation: train.bearing,
        scale: 4,
        strokeWeight: 1
      };
    };

    Helpers.getIcon = function(line) {
      return {
        scaledSize: new google.maps.Size(24, 24),
        anchor: new google.maps.Point(12, 12),
        url: Helpers.getLineIcon(line)
      };
    };

    Helpers.dateToTime = function(date) {
      var amPm, hours, minutes;
      hours = (date.getHours() - 1) % 12 + 1;
      minutes = date.getMinutes().leftPad(2);
      amPm = date.getHours() >= 12 ? 'pm' : 'am';
      return "" + hours + ":" + minutes + " " + amPm;
    };

    Helpers.secondsToTimeString = function(time) {
      var minutes;
      minutes = Math.floor(time / 60);
      if (minutes > 0) {
        return minutes + ' mins';
      } else {
        return 'Arr';
      }
    };

    Helpers.vehicleName = function(modeName) {
      var vehicleNameMap;
      vehicleNameMap = {
        'Subway': 'trains',
        'Bus': 'buses',
        'Commuter Rail': 'trains'
      };
      return vehicleNameMap[modeName];
    };

    Helpers.mergePredictions = function(predictions) {
      var key, mergeDirectionPair, mergePair, mergePredictionPair, mergeRoutePair, newPredictions, prediction, val, _i, _len, _results;
      mergePair = function(pair, subarrayExtractor, keyExtractor, mergeFunction) {
        var currentValue, element, key, newSet, val, _i, _len, _ref, _results;
        newSet = {};
        _ref = subarrayExtractor(pair[1]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          currentValue = newSet[keyExtractor(element)];
          if (!currentValue) {
            newSet[keyExtractor(element)] = element;
          } else {
            newSet[keyExtractor(element)] = mergeFunction(currentValue, element);
          }
        }
        _results = [];
        for (key in newSet) {
          val = newSet[key];
          _results.push(val);
        }
        return _results;
      };
      mergePredictionPair = function(prediction, secondPrediction) {
        var keyExtractor, subarrExtractor;
        subarrExtractor = function(prediction) {
          return prediction.routes;
        };
        keyExtractor = function(route) {
          return route.self.name;
        };
        return _.extend(prediction, {
          routes: mergePair([prediction, secondPrediction], subarrExtractor, keyExtractor, mergeRoutePair)
        });
      };
      mergeRoutePair = function(route, secondRoute) {
        var keyExtractor, subarrExtractor;
        subarrExtractor = function(route) {
          return route.directions;
        };
        keyExtractor = function(direction) {
          return direction.name;
        };
        return _.extend(route, {
          directions: mergePair([route, secondRoute])
        }, subarrExtractor, keyExtractor, mergeDirectionPair);
      };
      mergeDirectionPair = function(dir, secondDir) {
        return {
          minutesAway: Math.min(dir.minutesAway, secondDir.minutesAway),
          minutesBetweenVehicles: dir.minutesBetweenVehicles,
          name: dir.name,
          predictedNextArrival: _.min([dir.predictedNextArrival, secondDir.predictedNextArrival]),
          trips: dir.trips.concat(secondDir.trips).sort(function(a, b) {
            return parseInt(b.pre_away) - parseInt(a.pre_away);
          })
        };
      };
      newPredictions = {};
      for (_i = 0, _len = predictions.length; _i < _len; _i++) {
        prediction = predictions[_i];
        if (!newPredictions[prediction.type]) {
          newPredictions[prediction.type] = prediction;
        } else {
          newPredictions[prediction.type] = mergePredictionPair(newPredictions[prediction.type], prediction);
        }
      }
      _results = [];
      for (key in newPredictions) {
        val = newPredictions[key];
        _results.push(val);
      }
      return _results;
    };

    return Helpers;

  })();

  this.Template = (function() {

    Template.formats = {
      locales: "en-US",
      formats: {
        time: {
          hhmm: {
            hour: "numeric",
            minute: "numeric"
          }
        },
        relative: {
          minutes: {
            units: "minute"
          }
        }
      }
    };

    function Template(name, compiledCallback) {
      var setCompiledData,
        _this = this;
      this.compiled = false;
      this._template = null;
      setCompiledData = function(data) {
        _this._template = data;
        return _this.compiled = true;
      };
      $.get("hb/" + name + ".hdbs", function(data) {
        setCompiledData(Handlebars.compile(data));
        return compiledCallback();
      });
    }

    Template.prototype.render = function(context) {
      return this.compiled && this._template(context, {
        data: {
          intl: Template.formats
        }
      });
    };

    return Template;

  })();

  this.Marker = (function() {

    function Marker(lat, lng, category) {
      this.lat = lat;
      this.lng = lng;
      this.category = category;
      this.destroy = __bind(this.destroy, this);

      this.render = __bind(this.render, this);

    }

    Marker.prototype.render = function() {
      return this.marker = Mapper.placeMarker(this);
    };

    Marker.prototype.destroy = function() {
      if (this.marker) {
        return this.marker.setMap(null);
      } else {
        return console.warn(this);
      }
    };

    return Marker;

  })();

  this.LocationMarker = (function(_super) {

    __extends(LocationMarker, _super);

    function LocationMarker(lat, lng) {
      this.lat = lat;
      this.lng = lng;
      this.render = __bind(this.render, this);

      this.category = 'Location';
    }

    LocationMarker.prototype.render = function() {
      return this.marker = Mapper.placeMarker(this.lat, this.lng, this.category, Helpers.getIcon(this.category));
    };

    return LocationMarker;

  })(Marker);

  this.Stop = (function(_super) {

    __extends(Stop, _super);

    function Stop(id, name, lat, lng, category) {
      this.id = id;
      this.name = name;
      this.lat = lat;
      this.lng = lng;
      this.category = category;
      this.onClick = __bind(this.onClick, this);

      this.render = __bind(this.render, this);

      Stop.__super__.constructor.call(this, this.lat, this.lng, this.category);
      Helpers.cache.stops[this.id] = this;
    }

    Stop.prototype.render = function() {
      this.marker = Mapper.placeMarker(this.lat, this.lng, this.name, Helpers.getIcon(this.category));
      if (!this.marker) {
        console.log(this.marker);
      }
      return this.listener = google.maps.event.addListener(this.marker, 'click', this.onClick);
    };

    Stop.fromRawApi = function(api) {
      return Helpers.cache.stops[api.stop_id] || new Stop(api.stop_id, api.stop_name, parseFloat(api.stop_lat), parseFloat(api.stop_lon), "Bus");
    };

    Stop.isMainStop = function(id, parentStation) {
      return Mapper.defaultStopIds.indexOf(id) !== -1 || parentStation !== "";
    };

    Stop.prototype.onClick = function() {
      var stopAndChildren,
        _this = this;
      Helpers.events.fire('stop-selected', this);
      stopAndChildren = [this.id].concat(jsonData.stop_descendants[this.id] || []);
      return async.map(stopAndChildren, (function(stopId, callback) {
        return Mbta.getNextTrainsToStop({
          id: stopId
        }, {
          success: function(result) {
            return callback(null, result);
          },
          error: function(err) {
            return callback(err);
          }
        });
      }), function(err, predictions) {
        var result;
        if (err) {
          return Helpers.events.fire('stop-fetchdata-error', _this);
        } else {
          result = Helpers.mergePredictions(_.flatten(predictions));
          if (!(result.length > 0)) {
            Helpers.events.fire('stop-fetchdata-error', _this);
            console.warn("No predictions found for stop " + result.stop_name + " (ID " + result.stop_id + ")");
            return;
          }
          Helpers.events.fire('mbta-predictions', {
            stop_name: _this.name,
            predictions: result
          });
          return Helpers.events.fire('stop-fetchdata-success', _this);
        }
      });
    };

    return Stop;

  })(Marker);

  this.Vehicle = (function(_super) {

    __extends(Vehicle, _super);

    function Vehicle() {
      this.render = __bind(this.render, this);
      return Vehicle.__super__.constructor.apply(this, arguments);
    }

    Vehicle.prototype.render = function() {
      return this.marker = Mapper.placeVehicleMarker(this);
    };

    return Vehicle;

  })(Marker);

  this.LiveTrain = (function(_super) {

    __extends(LiveTrain, _super);

    function LiveTrain(id, line, destination, lat, lng, bearing) {
      this.id = id;
      this.line = line;
      this.destination = destination;
      LiveTrain.__super__.constructor.call(this, parseFloat(lat), parseFloat(lng), this.line);
      this.bearing = parseInt(bearing);
      Helpers.cache.vehicles[this.id] = this;
    }

    return LiveTrain;

  })(Vehicle);

  this.Alert = (function() {

    function Alert(text) {
      this.text = text;
      this.timestamp = new Date();
    }

    Alert.prototype.matches = function(text) {
      return this.text === text;
    };

    Alert.prototype.equals = function(thing) {
      return this === thing || this.matches(thing);
    };

    return Alert;

  })();

  this.Route = (function() {

    function Route(id, name, mode, stops, vehicles) {
      var _ref, _ref1;
      this.id = id;
      this.name = name;
      this.mode = mode;
      this.stops = stops;
      this.vehicles = vehicles;
      this.color = Helpers.getLineColor(this.id);
      if ((_ref = this.stops) == null) {
        this.stops = [];
      }
      if ((_ref1 = this.vehicles) == null) {
        this.vehicles = [];
      }
      Helpers.cache.routes[this.id] = this;
    }

    Route.prototype.setVehicles = function(vehicles) {
      Mapper.featureManager.addFeature("live-vehicles", vehicles);
      return this.vehicles = vehicles;
    };

    Route.fromRawApi = function(api) {
      var _base, _name, _ref;
      return (_ref = (_base = Helpers.cache.routes)[_name = api.route_id]) != null ? _ref : _base[_name] = new Route(api.route_id, api.route_name, "Subway");
    };

    Route.getShapes = function(id, callback) {
      return async.map(jsonData.shapes_by_route[id], function(shapeId, subCallback) {
        return Helpers.fetchLocalJson("shapes/routes/" + shapeId + ".json", function(shapes) {
          return subCallback(null, shapes);
        });
      }, function(error, shapeSet) {
        return callback(_.map(shapeSet, function(latLons) {
          return _.map(latLons, function(point) {
            return {
              lat: point.lat,
              lng: point.lon
            };
          });
        }));
      });
    };

    Route.prototype.render = function(renderStops) {
      var _this = this;
      Route.getShapes(this.id, function(shapes) {
        var _ref;
        if ((_ref = _this.paths) == null) {
          _this.paths = shapes.map(function(shape) {
            return new google.maps.Polyline({
              path: shape,
              strokeColor: _this.color,
              strokeOpacity: _this.opacity(),
              strokeWeight: 5
            });
          });
        }
        return _this.paths.map(function(path) {
          return path.setMap(Mapper.map);
        });
      });
      if (renderStops) {
        return this.stops.map(function(stop) {
          return stop.render();
        });
      }
    };

    Route.prototype.destroy = function() {
      var _ref;
      if ((_ref = this.paths) != null) {
        _ref.map(function(path) {
          return path.setMap(null);
        });
      }
      this.paths = null;
      return this.stops.map(function(stop) {
        return stop.destroy();
      });
    };

    Route.prototype.opacity = function() {
      return 1.0;
    };

    return Route;

  })();

  window.templates = {};

  window.jsonData = {};

  $(function() {
    var compileTemplates, loadJson, registerHandlebarsHelpers;
    registerHandlebarsHelpers = function() {
      Handlebars.registerHelper('time', function(date) {
        return date.toLocaleString('en-US', {
          timeZone: "America/New_York",
          hour: "numeric",
          minute: "numeric"
        });
      });
      return Handlebars.registerHelper('arriving', function(date) {
        var minutesAway;
        minutesAway = new Date(date - new Date()).getMinutes();
        if (minutesAway === 0) {
          return "Arriving";
        } else {
          return "" + minutesAway + " minutes";
        }
      });
    };
    compileTemplates = function(compiledCallback) {
      registerHandlebarsHelpers();
      return async.map(['prediction-info', 'alerts'], function(templateName, callback) {
        return window.templates[templateName] = new Template(templateName, callback);
      }, function(error, success) {
        if (error) {
          return compiledCallback("FATAL: Could not load templates. " + error);
        } else {
          Helpers.events.fire('templates-rendered');
          return compiledCallback();
        }
      });
    };
    loadJson = function(loadedCallback) {
      return async.map(['default_stops', 'google_style', 'routes', 'routes_by_line', 'shapes_by_route', 'stops', 'stop_descendants'], function(jsonName, callback) {
        return Helpers.fetchLocalJson("js/json/" + jsonName + ".json", function(data) {
          window.jsonData[jsonName] = data;
          return callback();
        });
      }, function(error, success) {
        if (error) {
          console.error(error);
          return loadedCallback("FATAL: Could not load JSON. " + error);
        } else {
          Helpers.events.fire('json-loaded');
          return loadedCallback();
        }
      });
    };
    return async.map([loadJson, compileTemplates], function(prepFunction, callback) {
      return prepFunction(callback);
    }, function(error, success) {
      if (error) {
        return console.error(error);
      } else {
        return Helpers.events.fire('prep-complete');
      }
    });
  });

}).call(this);
