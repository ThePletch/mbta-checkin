// Generated by CoffeeScript 1.10.0
(function() {
  this.Mapper = (function() {
    function Mapper() {}

    Mapper.map = null;

    Mapper.center = {
      lat: 42.358,
      lng: -71.064
    };

    Mapper.selected = null;

    Mapper.zoom = 14;

    Mapper.click = {
      stopMarker: function(marker) {
        Mapper.markStopSelected(marker);
        return Mbta.getNextTrainsToStop(marker.id, {
          success: function(result) {
            Helpers.events.fire('mapper-mbta-alerts', result.alert_headers.map(function(a) {
              return a.header_text;
            }));
            $.each(result.mode, function(i, mode) {
              mode.vehicle_name = Helpers.vehicleName(mode.mode_name);
              return $.each(mode.route, function(j, route) {
                route.route_name += " (" + route.direction[0].trip[0].trip_headsign + ")";
                return $.each(route.direction, function(k, dir) {
                  var last_trip_scheduled, sum_time_between;
                  sum_time_between = 0;
                  last_trip_scheduled = -1;
                  $.each(dir.trip, function(l, trip) {
                    if (last_trip_scheduled !== -1) {
                      sum_time_between += parseInt(trip.pre_dt) - last_trip_scheduled;
                    } else {
                      sum_time_between += parseInt(trip.pre_away);
                    }
                    return last_trip_scheduled = parseInt(trip.pre_dt);
                  });
                  dir.time_between_trains = Math.round((sum_time_between / dir.trip.length) / 60) + "m";
                  dir.predict_str = Helpers.dateToTime(new Date(parseInt(dir.trip[0].pre_dt) * 1000));
                  return dir.away_str = Helpers.secondsToTimeString(parseInt(dir.trip[0].pre_away));
                });
              });
            });
            Helpers.events.fire('mapper-mbta-predictions', result);
            return Mapper.markSelectedStopState('success');
          },
          error: function(error) {
            return Mapper.markSelectedStopState('error');
          }
        });
      }
    };

    Mapper.initialize = function() {
      Mapper.map = new google.maps.Map(document.getElementById('viewport'), {
        center: Mapper.center,
        zoom: Mapper.zoom,
        styles: jsonData.google_style,
        backgroundColor: '#2a2a2a',
        disableDefaultUI: true
      });
      Helpers.events.bind('modal-closed', Mapper.removeSelected);
      Helpers.events.bind('ui-location-found', Mapper.zoomToLocation);
      Mapper.placeStopMarkers(jsonData.all_stops);
      return Mapper.drawLineShapes();
    };

    Mapper.drawLineShapes = function() {
      return $.get("shapes/route_shapes.json", function(routes) {
        var len, m, ref, results, route, shape;
        if ((ref = typeof routes) === String || ref === 'string') {
          routes = JSON.parse(routes);
        }
        results = [];
        for (m = 0, len = routes.length; m < len; m++) {
          route = routes[m];
          if (route.shapes) {
            results.push((function() {
              var len1, n, ref1, results1;
              ref1 = route.shapes;
              results1 = [];
              for (n = 0, len1 = ref1.length; n < len1; n++) {
                shape = ref1[n];
                results1.push(Mapper.mapShapeFromLatLonList(shape, "#" + route.color));
              }
              return results1;
            })());
          } else {
            results.push(console.log(route));
          }
        }
        return results;
      });
    };

    Mapper.mapShapeFromLatLonList = function(latLonList, color) {
      var path, polyPoints;
      polyPoints = _.map(latLonList, function(point) {
        return {
          lat: point.lat,
          lng: point.lon
        };
      });
      path = new google.maps.Polyline({
        path: polyPoints,
        strokeColor: color,
        strokeOpacity: 1.0,
        strokeWeight: 5
      });
      return path.setMap(Mapper.map);
    };

    Mapper.markSelectedStopState = function(state) {
      var currentIcon;
      currentIcon = Mapper.selected.getIcon();
      currentIcon.url = (function() {
        switch (state) {
          case 'error':
            return Helpers.iconUrls.selectedError;
          case 'success':
            return Helpers.iconUrls.selectedSuccess;
        }
      })();
      return Mapper.selected.setIcon(currentIcon);
    };

    Mapper.markStopSelected = function(marker) {
      if (Mapper.selected != null) {
        Mapper.removeSelected();
      }
      return Mapper.selected = new google.maps.Marker({
        position: new google.maps.LatLng(marker.lat, marker.lng),
        map: Mapper.map,
        icon: {
          url: Helpers.iconUrls.selected,
          scaledSize: new google.maps.Size(33, 33),
          anchor: new google.maps.Point(16, 16)
        }
      });
    };

    Mapper.placeVehicleMarker = function(marker) {
      return new google.maps.Marker({
        position: new google.maps.LatLng(marker.lat, marker.lng),
        map: Mapper.map,
        title: marker.destination,
        icon: marker.icon || Helpers.getLiveIcon(marker)
      });
    };

    Mapper.placeStopMarker = function(marker) {
      var gMarker;
      gMarker = new google.maps.Marker({
        position: new google.maps.LatLng(marker.lat, marker.lng),
        map: Mapper.map,
        title: marker.name,
        icon: marker.icon || Helpers.getIcon(marker)
      });
      google.maps.event.addListener(gMarker, 'click', function() {
        return Mapper.click.stopMarker(marker);
      });
      return gMarker;
    };

    Mapper.placeStopMarkers = function(markers, extractor) {
      if (extractor == null) {
        extractor = function(marker) {
          return marker;
        };
      }
      return $.each(markers, function(i, marker) {
        return Mapper.placeStopMarker(extractor(marker));
      });
    };

    Mapper.removeSelected = function() {
      Mapper.selected.setMap(null);
      return Mapper.selected = null;
    };

    Mapper.zoomToLocation = function(location) {
      Mapper.map.setCenter(new google.maps.LatLng(location.latitude, location.longitude));
      return Mapper.map.setZoom(16);
    };

    return Mapper;

  })();

}).call(this);
